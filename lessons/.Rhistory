# Convert each tibble in the list to a matrix
grouped_matrices <- lapply(grouped_matrices, function(df) as.matrix(df[, -(1:3)]))
# Apply `rankorderseg` to calculate segregation indices
seg_results <- lapply(grouped_matrices, function(mat) {
tryCatch(OasisR::rankorderseg(mat), error = function(e) NULL)
})
# Combine results with identifiers
seg_results_combined <- Map(function(mat, res) {
if (is.null(res)) return(NULL)  # Skip errors
data.frame(
Hr.Index = res$Hr,
Rr.Index = res$Rr,
Sr.Index = res$Sr
)
}, grouped_matrices, seg_results)
# Step 6: Combine all results into a single dataframe
seg_income <- do.call(rbind, seg_results_combined)
seg_income$id <- rownames(seg_income)
# Parse identifiers and include year, race, and geo-level information
seg_income <- seg_income %>%
separate(id, into = c(group_var, "Race", "Year", "additional"), sep = "\\.", extra = "merge") %>%
mutate(Year = as.integer(Year)) %>%
select(all_of(c(group_var, "Race", "Year")), everything(), -additional)
return(seg_income)
}
# Apply the function for CBSA-level segregation
seg_income_cbsa <- calculate_income_segregation(geo = "cbsa")
calculate_income_segregation <- function(df, geo = "cbsa") {
# Define your income mapping for different years
income_mapping <- list(
`1980` = c("5k", "7.5k", "10k", "15k", "20k", "25k", "35k", "50k", "50.k"),
`1990` = c("5k", "10k", "15k", "25k", "35k", "50k", "75k", "100k", "100.k"),
`2000` = c("10k", "15k", "20k", "25k", "30k", "35k", "40k", "45k", "50k",
"60k", "75k", "100k", "125k", "150k", "200k", "200.k"),
`2012` = c("10k", "15k", "20k", "25k", "30k", "35k", "40k", "45k", "50k",
"60k", "75k", "100k", "125k", "150k", "200k", "200.k"),
`2019` = c("10k", "15k", "20k", "25k", "30k", "35k", "40k", "45k", "50k",
"60k", "75k", "100k", "125k", "150k", "200k", "200.k")
)
# Validate geo argument
if (!geo %in% c("cbsa", "place")) {
stop("Invalid `geo` argument. Use 'cbsa' or 'place'.")
}
# Set grouping variable based on `geo`
group_var <- if (geo == "cbsa") "cbsa_id" else "place_id"
# Filter relevant years based on income_mapping
df <- df %>%
filter(Year %in% names(income_mapping))
# Pivot income data into long format
income_data <- df %>%
pivot_longer(
cols = matches("^hh_(White|Black|Asian|Hispanic)_income_"),
names_to = c("Race", "Income"),
names_pattern = "hh_(.*?)_income_(.*)",
values_to = "value"
) %>%
filter(!is.na(value)) %>%
group_by(across(all_of(c(group_var, "Race", "Year", "Income")))) %>%
summarise(value = sum(value, na.rm = TRUE), .groups = 'drop') %>%
filter(Income %in% unlist(income_mapping[as.character(Year)])) %>%
pivot_wider(
names_from = Income,
values_from = value,
values_fill = list(value = 0)  # Fill missing income categories with 0
)
# Split data into matrices by grouping variables
grouped_matrices <- split(
income_data,
list(income_data[[group_var]], income_data$Race, income_data$Year),
drop = TRUE
)
# Convert each tibble in the list to a matrix
grouped_matrices <- lapply(grouped_matrices, function(df) {
if (nrow(df) == 0) return(NULL)  # Skip empty dataframes
as.matrix(df[, -(1:3)])  # Exclude grouping columns
})
# Filter out NULL matrices
grouped_matrices <- grouped_matrices[!sapply(grouped_matrices, is.null)]
# Apply `rankorderseg` to calculate segregation indices
seg_results <- lapply(grouped_matrices, function(mat) {
tryCatch(OasisR::rankorderseg(mat), error = function(e) NULL)
})
# Combine results with identifiers, skipping NULLs
seg_results_combined <- Map(function(mat, res) {
if (is.null(res)) return(NULL)  # Skip errors
data.frame(
Hr.Index = res$Hr,
Rr.Index = res$Rr,
Sr.Index = res$Sr
)
}, grouped_matrices, seg_results)
# Filter out NULL results
seg_results_combined <- seg_results_combined[!sapply(seg_results_combined, is.null)]
# Combine all results into a single dataframe
seg_income <- do.call(rbind, seg_results_combined)
if (is.null(seg_income)) {
stop("No valid results to process. Check your input data or income mapping.")
}
seg_income$id <- rownames(seg_income)
# Parse identifiers and include year, race, and geo-level information
seg_income <- seg_income %>%
separate(id, into = c(group_var, "Race", "Year", "additional"), sep = "\\.", extra = "merge") %>%
mutate(Year = as.integer(Year)) %>%
select(all_of(c(group_var, "Race", "Year")), everything(), -additional)
return(seg_income)
}
# Example Usage
seg_income_cbsa <- calculate_income_segregation(df, geo = "cbsa")
filtered_data <- df %>%
filter(Year %in% names(income_mapping)) %>%
pivot_longer(
cols = matches("^hh_(White|Black|Asian|Hispanic)_income_"),
names_to = c("Race", "Income"),
names_pattern = "hh_(.*?)_income_(.*)",
values_to = "value"
) %>%
filter(!is.na(value)) %>%
filter(Income %in% unlist(income_mapping[as.character(Year)]))
glimpse(filtered_data)
income_data <- filtered_data %>%
group_by(cbsa_id, Race, Year, Income) %>%
summarise(value = sum(value, na.rm = TRUE), .groups = 'drop') %>%
pivot_wider(
names_from = Income,
values_from = value,
values_fill = list(value = 0)
)
income_data
grouped_matrices <- split(
income_data,
list(income_data$cbsa_id, income_data$Race, income_data$Year),
drop = TRUE
)
length(grouped_matrices)  # Check the number of groups
grouped_matrices
length(grouped_matrices[1])  # Check the number of groups
grouped_matrices[1]
glimpse(filtered_data)
glimpse(grouped_matrices[1])
income_data <- filtered_data %>%
group_by(cbsa_id, Race, Year, Income) %>%
summarise(value = sum(value, na.rm = TRUE), .groups = 'drop') %>%
filter(Income %in% unlist(income_mapping[as.character(Year)])) %>%
pivot_wider(
names_from = Income,
values_from = value,
values_fill = list(value = 0)
)
grouped_matrices <- lapply(grouped_matrices, function(df) {
# Retain only columns present in income_mapping for the specific year
year <- unique(df$Year)
valid_columns <- unlist(income_mapping[as.character(year)])
valid_data <- df %>%
select(any_of(c("cbsa_id", "Race", "Year", valid_columns)))  # Keep only valid columns
as.matrix(valid_data[, -(1:3)])  # Convert to matrix after removing grouping columns
})
glimpse(grouped_matrices[1])
grouped_matrices[1]
grouped_matrices[2]
calculate_income_segregation <- function(df, geo = "cbsa") {
income_mapping <- list(
`1980` = c("5k", "7.5k", "10k", "15k", "20k", "25k", "35k", "50k", "50.k"),
`1990` = c("5k", "10k", "15k", "25k", "35k", "50k", "75k", "100k", "100.k"),
`2000` = c("10k", "15k", "20k", "25k", "30k", "35k", "40k", "45k", "50k",
"60k", "75k", "100k", "125k", "150k", "200k", "200.k"),
`2012` = c("10k", "15k", "20k", "25k", "30k", "35k", "40k", "45k", "50k",
"60k", "75k", "100k", "125k", "150k", "200k", "200.k"),
`2019` = c("10k", "15k", "20k", "25k", "30k", "35k", "40k", "45k", "50k",
"60k", "75k", "100k", "125k", "150k", "200k", "200.k")
)
if (!geo %in% c("cbsa", "place")) stop("Invalid `geo` argument. Use 'cbsa' or 'place'.")
group_var <- if (geo == "cbsa") "cbsa_id" else "place_id"
df <- df %>%
filter(Year %in% names(income_mapping)) %>%
pivot_longer(
cols = matches("^hh_(White|Black|Asian|Hispanic)_income_"),
names_to = c("Race", "Income"),
names_pattern = "hh_(.*?)_income_(.*)",
values_to = "value"
) %>%
filter(!is.na(value)) %>%
filter(Income %in% unlist(income_mapping[as.character(Year)])) %>%
group_by(across(all_of(c(group_var, "Race", "Year", "Income")))) %>%
summarise(value = sum(value, na.rm = TRUE), .groups = 'drop') %>%
pivot_wider(
names_from = Income,
values_from = value,
values_fill = list(value = 0)
) %>%
mutate(value = round(value, 0))
grouped_matrices <- split(
df,
list(df[[group_var]], df$Race, df$Year),
drop = TRUE
)
grouped_matrices <- lapply(grouped_matrices, function(df) {
year <- unique(df$Year)
valid_columns <- unlist(income_mapping[as.character(year)])
valid_data <- df %>%
select(any_of(c(group_var, "Race", "Year", valid_columns)))
as.matrix(valid_data[, -(1:3)])
})
seg_results <- lapply(grouped_matrices, function(mat) {
tryCatch(OasisR::rankorderseg(mat), error = function(e) NULL)
})
seg_results_combined <- Map(function(mat, res) {
if (is.null(res)) return(NULL)
data.frame(
Hr.Index = res$Hr,
Rr.Index = res$Rr,
Sr.Index = res$Sr,
id = paste0(mat[1, "cbsa_id"], ".", mat[1, "Race"], ".", mat[1, "Year"])
)
}, grouped_matrices, seg_results)
seg_results_combined <- Filter(Negate(is.null), seg_results_combined)
if (length(seg_results_combined) == 0) stop("No valid results to process.")
seg_income <- do.call(rbind, seg_results_combined)
seg_income <- seg_income %>%
separate(id, into = c(group_var, "Race", "Year", "additional"), sep = "\\.", extra = "merge") %>%
mutate(Year = as.integer(Year)) %>%
select(all_of(c(group_var, "Race", "Year")), everything(), -additional)
return(seg_income)
}
# Example Usage
seg_income_cbsa <- calculate_income_segregation(df, geo = "cbsa")
calculate_income_segregation <- function(df, geo = "cbsa") {
income_mapping <- list(
`1980` = c("5k", "7.5k", "10k", "15k", "20k", "25k", "35k", "50k", "50.k"),
`1990` = c("5k", "10k", "15k", "25k", "35k", "50k", "75k", "100k", "100.k"),
`2000` = c("10k", "15k", "20k", "25k", "30k", "35k", "40k", "45k", "50k",
"60k", "75k", "100k", "125k", "150k", "200k", "200.k"),
`2012` = c("10k", "15k", "20k", "25k", "30k", "35k", "40k", "45k", "50k",
"60k", "75k", "100k", "125k", "150k", "200k", "200.k"),
`2019` = c("10k", "15k", "20k", "25k", "30k", "35k", "40k", "45k", "50k",
"60k", "75k", "100k", "125k", "150k", "200k", "200.k")
)
if (!geo %in% c("cbsa", "place")) stop("Invalid `geo` argument. Use 'cbsa' or 'place'.")
group_var <- if (geo == "cbsa") "cbsa_id" else "place_id"
df <- df %>%
filter(Year %in% names(income_mapping)) %>%
pivot_longer(
cols = matches("^hh_(White|Black|Asian|Hispanic)_income_"),
names_to = c("Race", "Income"),
names_pattern = "hh_(.*?)_income_(.*)",
values_to = "value"
) %>%
filter(!is.na(value)) %>%
filter(Income %in% unlist(income_mapping[as.character(Year)])) %>%
group_by(across(all_of(c(group_var, "Race", "Year", "Income")))) %>%
summarise(value = sum(value, na.rm = TRUE), .groups = 'drop') %>%
mutate(value = round(value, 0)) %>%
pivot_wider(
names_from = Income,
values_from = value,
values_fill = list(value = 0)
)
grouped_matrices <- split(
df,
list(df[[group_var]], df$Race, df$Year),
drop = TRUE
)
grouped_matrices <- lapply(grouped_matrices, function(df) {
year <- unique(df$Year)
valid_columns <- unlist(income_mapping[as.character(year)])
valid_data <- df %>%
select(any_of(c(group_var, "Race", "Year", valid_columns)))
as.matrix(valid_data[, -(1:3)])
})
seg_results <- lapply(grouped_matrices, function(mat) {
tryCatch(OasisR::rankorderseg(mat), error = function(e) NULL)
})
seg_results_combined <- Map(function(mat, res) {
if (is.null(res)) return(NULL)
data.frame(
Hr.Index = res$Hr,
Rr.Index = res$Rr,
Sr.Index = res$Sr,
id = paste0(mat[1, "cbsa_id"], ".", mat[1, "Race"], ".", mat[1, "Year"])
)
}, grouped_matrices, seg_results)
seg_results_combined <- Filter(Negate(is.null), seg_results_combined)
if (length(seg_results_combined) == 0) stop("No valid results to process.")
seg_income <- do.call(rbind, seg_results_combined)
seg_income <- seg_income %>%
separate(id, into = c(group_var, "Race", "Year", "additional"), sep = "\\.", extra = "merge") %>%
mutate(Year = as.integer(Year)) %>%
select(all_of(c(group_var, "Race", "Year")), everything(), -additional)
return(seg_income)
}
# Example Usage
seg_income_cbsa <- calculate_income_segregation(df, geo = "cbsa")
calculate_income_segregation <- function(df, geo = "cbsa") {
income_mapping <- list(
`1980` = c("5k", "7.5k", "10k", "15k", "20k", "25k", "35k", "50k", "50.k"),
`1990` = c("5k", "10k", "15k", "25k", "35k", "50k", "75k", "100k", "100.k"),
`2000` = c("10k", "15k", "20k", "25k", "30k", "35k", "40k", "45k", "50k",
"60k", "75k", "100k", "125k", "150k", "200k", "200.k"),
`2012` = c("10k", "15k", "20k", "25k", "30k", "35k", "40k", "45k", "50k",
"60k", "75k", "100k", "125k", "150k", "200k", "200.k"),
`2019` = c("10k", "15k", "20k", "25k", "30k", "35k", "40k", "45k", "50k",
"60k", "75k", "100k", "125k", "150k", "200k", "200.k")
)
if (!geo %in% c("cbsa", "place")) stop("Invalid `geo` argument. Use 'cbsa' or 'place'.")
group_var <- if (geo == "cbsa") "cbsa_id" else "place_id"
df <- df %>%
filter(Year %in% names(income_mapping)) %>%
pivot_longer(
cols = matches("^hh_(White|Black|Asian|Hispanic)_income_"),
names_to = c("Race", "Income"),
names_pattern = "hh_(.*?)_income_(.*)",
values_to = "value"
) %>%
filter(!is.na(value), Income %in% unlist(income_mapping[as.character(Year)])) %>%
group_by(across(all_of(c(group_var, "Race", "Year", "Income")))) %>%
summarise(value = sum(value, na.rm = TRUE), .groups = 'drop') %>%
mutate(value = round(value, 0)) %>%
pivot_wider(
names_from = Income,
values_from = value,
values_fill = list(value = 0)
)
grouped_matrices <- split(
df,
list(df[[group_var]], df$Race, df$Year),
drop = TRUE
)
grouped_matrices <- lapply(grouped_matrices, function(df) {
year <- unique(df$Year)
valid_columns <- unlist(income_mapping[as.character(year)])
valid_data <- df %>%
select(any_of(c(group_var, "Race", "Year", valid_columns)))
as.matrix(valid_data[, -(1:3)])
})
seg_results <- lapply(grouped_matrices, function(mat) {
if (is.null(mat) || ncol(mat) == 0 || nrow(mat) == 0) return(NULL)
tryCatch(OasisR::rankorderseg(mat), error = function(e) NULL)
})
seg_results_combined <- Map(function(mat, res) {
if (is.null(res)) return(NULL)
data.frame(
Hr.Index = res$Hr,
Rr.Index = res$Rr,
Sr.Index = res$Sr,
id = paste0(mat[1, "cbsa_id"], ".", mat[1, "Race"], ".", mat[1, "Year"])
)
}, grouped_matrices, seg_results)
seg_results_combined <- Filter(Negate(is.null), seg_results_combined)
if (length(seg_results_combined) == 0) {
warning("No valid results to process. Returning an empty data frame.")
return(data.frame(cbsa_id = character(), Race = character(), Year = integer(), Hr.Index = numeric(), Rr.Index = numeric(), Sr.Index = numeric()))
}
seg_income <- do.call(rbind, seg_results_combined)
seg_income <- seg_income %>%
separate(id, into = c(group_var, "Race", "Year", "additional"), sep = "\\.", extra = "merge") %>%
mutate(Year = as.integer(Year)) %>%
select(all_of(c(group_var, "Race", "Year")), everything(), -additional)
return(seg_income)
}
calculate_income_segregation <- function(df, geo = "cbsa") {
income_mapping <- list(
`1980` = c("5k", "7.5k", "10k", "15k", "20k", "25k", "35k", "50k", "50.k"),
`1990` = c("5k", "10k", "15k", "25k", "35k", "50k", "75k", "100k", "100.k"),
`2000` = c("10k", "15k", "20k", "25k", "30k", "35k", "40k", "45k", "50k",
"60k", "75k", "100k", "125k", "150k", "200k", "200.k"),
`2012` = c("10k", "15k", "20k", "25k", "30k", "35k", "40k", "45k", "50k",
"60k", "75k", "100k", "125k", "150k", "200k", "200.k"),
`2019` = c("10k", "15k", "20k", "25k", "30k", "35k", "40k", "45k", "50k",
"60k", "75k", "100k", "125k", "150k", "200k", "200.k")
)
if (!geo %in% c("cbsa", "place")) stop("Invalid `geo` argument. Use 'cbsa' or 'place'.")
group_var <- if (geo == "cbsa") "cbsa_id" else "place_id"
df <- df %>%
filter(Year %in% names(income_mapping)) %>%
pivot_longer(
cols = matches("^hh_(White|Black|Asian|Hispanic)_income_"),
names_to = c("Race", "Income"),
names_pattern = "hh_(.*?)_income_(.*)",
values_to = "value"
) %>%
filter(!is.na(value), Income %in% unlist(income_mapping[as.character(Year)])) %>%
group_by(across(all_of(c(group_var, "Race", "Year", "Income")))) %>%
summarise(value = sum(value, na.rm = TRUE), .groups = 'drop') %>%
mutate(value = round(value, 0)) %>%
pivot_wider(
names_from = Income,
values_from = value,
values_fill = list(value = 0)
)
grouped_matrices <- split(
df,
list(df[[group_var]], df$Race, df$Year),
drop = TRUE
)
grouped_matrices <- lapply(grouped_matrices, function(df) {
year <- unique(df$Year)
valid_columns <- unlist(income_mapping[as.character(year)])
valid_data <- df %>%
select(any_of(c(group_var, "Race", "Year", valid_columns)))
as.matrix(valid_data[, -(1:3)])
})
seg_results <- lapply(grouped_matrices, function(mat) {
if (is.null(mat) || ncol(mat) == 0 || nrow(mat) == 0) return(NULL)
tryCatch(OasisR::rankorderseg(mat), error = function(e) NULL)
})
seg_results_combined <- Map(function(mat, res) {
if (is.null(res)) return(NULL)
data.frame(
Hr.Index = res$Hr,
Rr.Index = res$Rr,
Sr.Index = res$Sr,
id = paste0(mat[1, "cbsa_id"], ".", mat[1, "Race"], ".", mat[1, "Year"])
)
}, grouped_matrices, seg_results)
seg_results_combined <- Filter(Negate(is.null), seg_results_combined)
if (length(seg_results_combined) == 0) {
warning("No valid results to process. Returning an empty data frame.")
return(data.frame(cbsa_id = character(), Race = character(), Year = integer(), Hr.Index = numeric(), Rr.Index = numeric(), Sr.Index = numeric()))
}
seg_income <- do.call(rbind, seg_results_combined)
seg_income <- seg_income %>%
separate(id, into = c(group_var, "Race", "Year", "additional"), sep = "\\.", extra = "merge") %>%
mutate(Year = as.integer(Year)) %>%
select(all_of(c(group_var, "Race", "Year")), everything(), -additional)
return(seg_income)
}
seg_income_cbsa <- calculate_income_segregation(df, geo = "cbsa")
seg_income_cbsa
filtered_df <- df %>%
filter(Year %in% names(income_mapping))
print(nrow(filtered_df))  # Ensure rows exist for the filtered years
income_data <- filtered_df %>%
pivot_longer(
cols = matches("^hh_(White|Black|Asian|Hispanic)_income_"),
names_to = c("Race", "Income"),
names_pattern = "hh_(.*?)_income_(.*)",
values_to = "value"
) %>%
filter(!is.na(value))
print(nrow(income_data))  # Check row count after pivot
glimpse(income_data)
valid_income_data <- income_data %>%
filter(Income %in% unlist(income_mapping[as.character(Year)]))
print(nrow(valid_income_data))  # Ensure rows remain after filtering
glimpse(valid_income_data)
wide_data <- summarized_data %>%
pivot_wider(
names_from = Income,
values_from = value,
values_fill = list(value = 0)
)
summarized_data <- valid_income_data %>%
group_by(across(all_of(c(group_var, "Race", "Year", "Income")))) %>%
summarise(value = sum(value, na.rm = TRUE), .groups = 'drop') %>%
mutate(value = round(value, 0))
valid_income_data <- income_data %>%
filter(Income %in% unlist(income_mapping[as.character(Year)]))
print(nrow(valid_income_data))  # Ensure rows remain after filtering
glimpse(valid_income_data)
summarized_data <- valid_income_data %>%
group_by(across(all_of(c("cbsa_id", "Race", "Year", "Income")))) %>%
summarise(value = sum(value, na.rm = TRUE), .groups = 'drop') %>%
mutate(value = round(value, 0))
print(nrow(summarized_data))  # Ensure rows exist after summarization
glimpse(summarized_data)
wide_data <- summarized_data %>%
pivot_wider(
names_from = Income,
values_from = value,
values_fill = list(value = 0)
)
print(nrow(wide_data))  # Check row count
glimpse(wide_data)
grouped_matrices <- split(
wide_data,
list(wide_data[[group_var]], wide_data$Race, wide_data$Year),
drop = TRUE
)
grouped_matrices <- split(
wide_data,
list(wide_data$place_id, wide_data$Race, wide_data$Year),
drop = TRUE
)
glimpse(wide_data)
grouped_matrices <- split(
wide_data,
list(wide_data$cbsa_id, wide_data$Race, wide_data$Year),
drop = TRUE
)
print(length(grouped_matrices))  # Ensure matrices are created
glimpse(grouped_matrices[1])  # Inspect the first matrix
example_matrix <- grouped_matrices[[1]]
print(dim(example_matrix))  # Ensure the matrix has rows and columns
result <- tryCatch(OasisR::rankorderseg(example_matrix), error = function(e) e)
print(result)
p_load(OasisR)
install.packages("remotes")
remotes::install_github("Diego-Fernandez-Reyes/OasisR")
install.packages("/Users/taesoo/Downloads/OasisR_3.1.1.tar.gz", repos = NULL, type = "source")
library(OasisR)
install.packages("/Users/taesoo/Downloads/OasisR_3.1.1.tar.gz", repos = NULL, type = "source")
install.packages("devtools")
devtools::install_github("AndreaCirilloAC/updateR")
devtools::install_github("AndreaCirilloAC/updateR")
install.packages("shiny")
devtools::install_github("AndreaCirilloAC/updateR")
library(shiny)
devtools::install_github("AndreaCirilloAC/updateR")
install.packages("installr")
library(installr)
updateR()
R.version.string
updateR()
